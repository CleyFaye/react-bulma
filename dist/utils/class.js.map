{"version":3,"sources":["../../lib/utils/class.mjs"],"names":["addBreakpoint","classes","breakpoint","breakpointList","includes","Error","push","classString","extraClassName","split","classesSet","Set","size","undefined","Array","from","values","join","addClassFromList","property","list","transform","map","elem","addClassesFromOptions","propList","options","supportedOptions","Object","keys","reduce","supportedOptionName","option","supportedOption","addClassesWithViewportSuffix","onlyBreakpoint","acceptableList","viewportList","forEach","viewportName","className","breakName"],"mappings":"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","sourcesContent":["import {\n  breakpointList,\n  viewportList,\n} from \"./const\";\n\n/** Add the breakpoint as a CSS class if present\n * \n * @param {Array.<{string}>} classes\n * @param {string} breakpoint\n * \n * @returns {Array.<{string}>}\n * Return classes\n */\nexport const addBreakpoint = (classes, breakpoint) => {\n  if (!breakpoint) {\n    return classes;\n  }\n  if (!breakpointList.includes(breakpoint)) {\n    throw new Error(`Unexpected breakpoin \"${breakpoint}\"`);\n  }\n  classes.push(`is-${breakpoint}`);\n  return classes;\n};\n\n/** Return a class string from an array of classes\n * \n * @param {Array.<{string}>} classes\n * List of classes to use\n * \n * @param {string|Array.<{string}>} extraClassName\n * Extra classes to append to the list of classes.\n * Usually used to pull custom classes with the className prop.\n * Can be either a string or an array of strings.\n * \n * @returns {string}\n */\nexport const classString = (classes, extraClassName) => {\n  if (!classes) {\n    classes = [];\n  }\n  if (typeof classes === \"string\") {\n    classes = [classes];\n  }\n  if (extraClassName) {\n    if (typeof extraClassName == \"string\") {\n      extraClassName = extraClassName.split(\" \");\n    }\n  } else {\n    extraClassName = [];\n  }\n  const classesSet = new Set([...classes, ...extraClassName]);\n  return classesSet.size == 0\n    ? undefined\n    : Array.from(classesSet.values()).join(\" \");\n};\n\n/** Add a class in a list of classes according to a property value\n * \n * @param {Array.<{string}>} classes\n * @param {string} property\n * @param {Array.<{string}>} list\n * List of valid values for property\n * \n * @param {function} transform\n * Transformation to convert property to a value to append to classes.\n * Default to prepending \"is-\".\n * \n * @returns {Array.<string>}\n * Return classes\n */\nexport const addClassFromList = (classes, property, list, transform) => {\n  if ((typeof property) !== \"undefined\") {\n    if (!list.includes(property)) {\n      throw new Error(`Unexpected value \"${property}\" `\n        + `(must be ${list.map(elem => `\"${elem}\"`).join(\",\")})`);\n    }\n    classes.push(transform\n      ? transform(property)\n      : `is-${property}`);\n  }\n  return classes;\n};\n\n/** Add classes to a list of classes according to a set of options.\n * \n * @param {Array.<{string}>} classes\n * @param {hash} propList\n * @param {hash} options\n * Requested option from the caller\n * \n * @param {hash} supportedOptions\n * List of supported options. Each key is an option name, each value is an\n * object with these two properties:\n * - list: possible values for the property\n * - transform: transform function (see addClassFromList())\n * \n * @returns {Array.<{string}>}\n * Return classes\n * \n * @note\n * If options is undefined, all supported options are checked.:\n */\nexport const addClassesFromOptions = \n  (classes, propList, options, supportedOptions) => \n    Object.keys(supportedOptions).reduce((classes, supportedOptionName) => {\n      const option = options\n        ? options[supportedOptionName]\n        : true;\n      if (!option) {\n        return classes;\n      }\n      const supportedOption = supportedOptions[supportedOptionName];\n      return addClassFromList(\n        classes,\n        propList[(typeof option === \"string\")\n          ? option\n          : supportedOptionName],\n        supportedOption.list,\n        supportedOption.transform);\n    }, classes);\n\n/** Add classes to a list with viewport suffixed to them.\n * \n * @param {Array.<{string}>} classes\n * @param {string|hash} values\n * List of values for each viewport. Key are viewport names, values are\n * property values.\n * If a string is passed, no viewport prefix are added.\n * \n * @param {function} transform\n * Function that take as input a property value and returns the CSS class name.\n * \n * @param {bool} onlyBreakpoint\n * Only accept full breakpoint. If false, viewport definition are also accepted.\n * \n * @returns {Array.<{string}>}\n * Return classes\n */\nexport const addClassesWithViewportSuffix = (classes, values, transform, onlyBreakpoint) => {\n  if (!values) {\n    return classes;\n  }\n  const acceptableList = onlyBreakpoint\n    ? breakpointList\n    : viewportList;\n  if (typeof values === \"string\") {\n    classes.push(transform(values));\n  }\n  values = [values];\n  Object.keys(values).forEach(viewportName => {\n    if (!acceptableList[viewportName]) {\n      throw new Error(`Invalid viewport name \"${viewportName}\"`);\n    }\n    const className = transform(values[viewportName]);\n    if (!className) {\n      return;\n    }\n    const breakName = acceptableList[viewportName];\n    classes.push(`${className}-${breakName}`);\n  });\n  return classes;\n};"],"file":"class.js"}